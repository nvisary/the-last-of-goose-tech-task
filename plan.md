# План разработки "The Last of Guss"

Этот документ описывает план разработки браузерной игры "The Last of Guss" на основе предоставленной спецификации.

## 1. Выбор технологического стека

*   **Бекенд:**
    *   **Язык:** TypeScript (strict mode)
    *   **Платформа:** Node.js
    *   **Фреймворк API:** Fastify (за его скорость и низкие накладные расходы)
    *   **ORM:** Prisma (за строгую типизацию и удобную миграцию схемы данных)
    *   **База данных:** PostgreSQL
    *   **Аутентификация:** JWT (в виде http-only cookie для безопасности)

*   **Фронтенд:**
    *   **Язык:** TypeScript
    *   **Библиотека:** React
    *   **Сборщик:** Vite
    *   **Роутинг:** React-Router
    *   **UI:** Стилизация с помощью CSS Modules или Styled Components для соответствия макетам. UI-библиотеки не требуются.
    *   **Стейт-менеджер:** Zustand (за простоту и минималистичный API)

## 2. Фазы разработки

### Фаза 1: Настройка проекта и окружения

1.  **Инициализация монорепозитория:** Создать структуру проекта, где `backend` и `frontend` будут находиться в отдельных папках.
2.  **Настройка бекенда:**
    *   Инициализировать Node.js проект с TypeScript.
    *   Установить и настроить Fastify и Prisma.
    *   Настроить подключение к базе данных PostgreSQL.
    *   Создать `.env` файл для конфигурации (длительность раунда, cooldown, секрет для JWT, строка подключения к БД).
3.  **Настройка фронтенда:**
    *   Инициализировать React-проект с помощью Vite и шаблона TypeScript.
    *   Установить `react-router-dom`, `zustand` и другие необходимые зависимости.

### Фаза 2: Разработка бекенда

1.  **Проектирование схемы данных (Prisma Schema):**
    *   `User`: `id`, `username`, `password`, `role` (Admin, Survivor, Nikita).
    *   `Round`: `id`, `startTime`, `endTime`, `status` (Cooldown, Active, Finished), `totalScore`.
    *   `Tap`: `id`, `userId`, `roundId`, `score`, `createdAt`. Связь для отслеживания тапов каждого пользователя в раунде.
    *   `UserRound`: промежуточная таблица для хранения очков `score` и количества тапов `taps` для каждого `User` в каждом `Round`.

2.  **Реализация API эндпоинтов (Fastify):**
    *   **`POST /api/auth/login`**:
        *   Принимает `username` и `password`.
        *   Если пользователя нет, создает нового с соответствующей ролью (Admin/Nikita/Survivor).
        *   Если пользователь есть, проверяет пароль.
        *   Возвращает JWT в http-only cookie.
    *   **`GET /api/rounds`**:
        *   Возвращает список всех раундов.
        *   Доступен всем авторизованным пользователям.
    *   **`POST /api/rounds`**:
        *   Создает новый раунд. `startTime` вычисляется как `now() + COOLDOWN_DURATION`. `endTime` как `startTime + ROUND_DURATION`.
        *   Доступен только для роли `Admin`.
    *   **`GET /api/rounds/:id`**:
        *   Возвращает детальную информацию о раунде, включая его статус, победителя (если раунд завершен) и очки текущего пользователя.
    *   **`POST /api/rounds/:id/tap`**:
        *   **Ключевая логика:** этот эндпоинт должен быть максимально атомарным и быстрым.
        *   Проверка, что пользователь не "Никита".
        *   Проверка, что раунд находится в статусе "Active".
        *   **Транзакция в БД:**
            1.  Найти или создать запись `UserRound` для текущего пользователя и раунда.
            2.  Инкрементировать счетчик тапов (`taps`) в `UserRound`.
            3.  Вычислить очки: если `(taps + 1) % 11 === 0`, то `scoreToAdd = 10`, иначе `scoreToAdd = 1`.
            4.  Инкрементировать `score` в `UserRound` и `totalScore` в `Round`.
        *   Использовать `SELECT ... FOR UPDATE` в транзакции для блокировки строк `UserRound` и `Round` на время обновления, чтобы избежать race conditions при работе нескольких инстансов бекенда.
        *   Возвращает обновленное количество очков пользователя в раунде.

3.  **Реализация фоновых процессов:**
    *   Нужно реализовать механизм, который будет автоматически менять статусы раундов с `Cooldown` на `Active` и с `Active` на `Finished`. Это можно сделать с помощью `setInterval` на бекенде, который периодически проверяет и обновляет статусы раундов.

### Фаза 3: Разработка фронтенда

1.  **Создание базовой структуры:**
    *   Настроить роутинг для трех страниц: `/login`, `/` (список раундов), `/rounds/:id`.
    *   Создать layout с хедером, где будет отображаться имя пользователя.
    *   Реализовать защищенные роуты, которые будут доступны только после логина.

2.  **Реализация страниц:**
    *   **Страница логина (`/login`):**
        *   Форма с полями "Имя пользователя" и "Пароль".
        *   Обработчик для отправки запроса на `POST /api/auth/login`.
        *   Отображение ошибок под кнопкой.
    *   **Страница списка раундов (`/`):**
        *   Запрос на `GET /api/rounds` при загрузке.
        *   Отображение списка раундов с их статусами и датами.
        *   Каждый раунд — это ссылка на страницу `/rounds/:id`.
        *   Кнопка "Создать раунд" (видна только админам), которая отправляет запрос `POST /api/rounds` и перенаправляет на страницу нового раунда.
    *   **Страница раунда (`/rounds/:id`):**
        *   Запрос на `GET /api/rounds/:id` для получения данных о раунде.
        *   Отображение состояния раунда: Cooldown, Active, Finished.
        *   Таймер обратного отсчета (до начала или до конца раунда).
        *   Изображение гуся. Если раунд активен, по клику на гуся отправляется запрос `POST /api/rounds/:id/tap`.
        *   Отображение своих очков.
        *   Когда раунд завершен, отображается статистика: общий счет, победитель, свои очки.
        *   Состояние страницы должно динамически обновляться (например, через WebSockets или регулярные запросы на сервер). Для простоты можно использовать `setInterval` для поллинга данных раз в несколько секунд.

### Фаза 4: Интеграция и тестирование

1.  **Проксирование запросов:** Настроить Vite dev server для проксирования запросов с `/api` на бекенд, чтобы избежать проблем с CORS во время разработки.
2.  **Тестирование E2E (ручное):**
    *   Проверить флоу логина для разных ролей (Survivor, Admin, Nikita).
    *   Проверить создание раунда админом.
    *   Проверить механику тапов в активном раунде.
    *   Убедиться, что тапы "Никиты" не засчитываются в статистику.
    *   Проверить корректность отображения состояний раунда и статистики после его завершения.
    *   Протестировать одновременные тапы от нескольких пользователей (открыть несколько вкладок браузера).
3.  **Финальная сборка:** Подготовить `dist` папки для фронтенда и бекенда.
4.  **Документация:** Написать `readme.md` с инструкциями по запуску проекта.

# Теоретические аспекты бекенда для проекта "The Last of Guss"

Данный документ содержит теоретическое обоснование и подробности реализации бекенда для игры "The Last of Guss", с акцентом на выбранные технологии и ключевые решения.

## 1. Выбор технологического стека бекенда

*   **Node.js и TypeScript:** Выбраны из-за их производительности, обширной экосистемы и возможности использовать один язык (TypeScript) как для фронтенда, так и для бекенда, что упрощает разработку и поддержку. TypeScript обеспечивает статическую типизацию, улучшая надежность кода и упрощая отладку.
*   **Fastify:** Легковесный и высокопроизводительный веб-фреймворк для Node.js. Он был выбран из-за его скорости, низких накладных расходов и эффективной системы плагинов, что идеально подходит для создания RESTful API, где требуется высокая пропускная способность.
*   **Prisma:** Современный ORM (Object-Relational Mapper) для Node.js и TypeScript. Основные причины выбора Prisma:
    *   **Строгая типизация:** Автоматическая генерация TypeScript типов на основе схемы базы данных, что позволяет избежать многих ошибок на этапе компиляции.
    *   **Простота использования:** Интуитивно понятный API для взаимодействия с базой данных.
    *   **Миграции:** Удобные инструменты для управления миграциями схемы базы данных.
    *   **Производительность:** Эффективные запросы к БД.
*   **PostgreSQL:** Мощная, открытая, объектно-реляционная система управления базами данных. Выбрана за надежность, соответствие ACID-принципам, широкие возможности масштабирования и поддержку сложных транзакций, что критично для обеспечения консистентности данных.

## 2. Аутентификация и авторизация (JWT)

Для аутентификации будет использоваться **JSON Web Tokens (JWT)**.
*   **Механизм:** При успешном логине пользователя бекенд генерирует JWT, содержащий информацию о пользователе (например, `userId`, `username`, `role`).
*   **Передача токена:** JWT будет передаваться клиенту в **HTTP-only cookie**. Это повышает безопасность, так как такой cookie недоступен для JavaScript на стороне клиента, что снижает риск XSS-атак.
*   **Авторизация:** При каждом последующем запросе клиент отправляет этот cookie. Бекенд извлекает JWT, верифицирует его (проверяет подпись и срок действия) и использует информацию из токена для идентификации пользователя и проверки его прав доступа (авторизация).

## 3. Проектирование схемы базы данных (Prisma Schema)

Схема базы данных будет включать следующие модели:

*   **`User`:**
    *   `id`: `String @id @default(uuid())` - Уникальный идентификатор пользователя.
    *   `username`: `String @unique` - Имя пользователя, должно быть уникальным.
    *   `password`: `String` - Хэшированный пароль пользователя.
    *   `role`: `UserRole` - Роль пользователя (`Admin`, `Survivor`, `Nikita`).
    *   `rounds`: `UserRound[]` - Связь с таблицей `UserRound`, показывающая участие пользователя в раундах.

*   **`UserRole` (Enum):** `enum UserRole { ADMIN SURVIVOR NIKITA }`

*   **`Round`:**
    *   `id`: `String @id @default(uuid())` - Уникальный идентификатор раунда.
    *   `startTime`: `DateTime` - Время начала раунда.
    *   `endTime`: `DateTime` - Время завершения раунда.
    *   `status`: `RoundStatus` - Текущий статус раунда (`Cooldown`, `Active`, `Finished`).
    *   `totalScore`: `Int @default(0)` - Общее количество очков, набранных в данном раунде.
    *   `users`: `UserRound[]` - Связь с таблицей `UserRound`, показывающая всех участников раунда и их результаты.

*   **`RoundStatus` (Enum):** `enum RoundStatus { COOLDOWN ACTIVE FINISHED }`

*   **`UserRound` (промежуточная таблица для Many-to-Many связи с дополнительными полями):**
    *   `userId`: `String` - ID пользователя.
    *   `roundId`: `String` - ID раунда.
    *   `taps`: `Int @default(0)` - Количество тапов пользователя в данном раунде.
    *   `score`: `Int @default(0)` - Количество очков пользователя в данном раунде.
    *   `user`: `User @relation(fields: [userId], references: [id])` - Связь с моделью `User`.
    *   `round`: `Round @relation(fields: [roundId], references: [id])` - Связь с моделью `Round`.
    *   `@@id([userId, roundId])` - Составной первичный ключ для уникальности пары пользователь-раунд.

## 4. Дизайн API эндпоинтов

Согласно спецификации, будут реализованы следующие основные эндпоинты:

*   **`POST /api/auth/login`**:
    *   Вход в систему или регистрация нового пользователя.
    *   На основе `username` и `password`.
    *   Автоматическое назначение роли (`Admin`, `Survivor`, `Nikita`) по имени пользователя.

*   **`GET /api/rounds`**:
    *   Получение списка всех раундов с основной информацией.

*   **`POST /api/rounds`**:
    *   Создание нового раунда.
    *   Доступно только для пользователей с ролью `Admin`.
    *   `startTime` и `endTime` рассчитываются на бекенде на основе `COOLDOWN_DURATION` и `ROUND_DURATION`.

*   **`GET /api/rounds/:id`**:
    *   Получение детальной информации о конкретном раунде.
    *   Включает статус раунда, информацию о победителе (если раунд завершен), а также личные очки текущего пользователя в этом раунде.

*   **`POST /api/rounds/:id/tap`**:
    *   **Основной эндпоинт для игровой механики.**
    *   Обработка тапа по гусю.
    *   Возвращает обновленное количество очков пользователя в раунде.

## 5. Обработка Race Conditions и обеспечение консистентности данных

Это критически важный аспект для эндпоинта `POST /api/rounds/:id/tap`, где множество пользователей могут одновременно пытаться набрать очки. Для обеспечения консистентности данных и корректного расчета очков будут применены следующие меры:

*   **Транзакции базы данных:** Все операции, связанные с обновлением очков и тапов (проверка статуса раунда, проверка роли пользователя, инкремент счетчиков `taps` и `score` в `UserRound`, а также `totalScore` в `Round`), будут выполняться в рамках одной атомарной транзакции базы данных. Это гарантирует, что либо все изменения будут применены, либо ни одно из них, предотвращая частичные обновления и расхождения данных.

*   **Блокировка строк (Row-Level Locking) с `SELECT ... FOR UPDATE`:** При обработке запроса на тап, перед обновлением, будут заблокированы соответствующие строки в таблицах `UserRound` и `Round`. В PostgreSQL это достигается с помощью оператора `SELECT ... FOR UPDATE`.
    *   Когда запрос на тап приходит, транзакция будет сначала считывать текущие данные `UserRound` и `Round` с использованием `FOR UPDATE`.
    *   Это не позволит другим параллельным транзакциям изменять те же строки, пока текущая транзакция не будет завершена (commit или rollback).
    *   Таким образом, гарантируется, что каждый инкремент счетчиков происходит на основе актуальных значений, предотвращая потерю обновлений при одновременных запросах.

*   **Валидация на сервере:**
    *   **Статус раунда:** Перед обработкой тапа всегда будет проверяться, что `Round.status` находится в состоянии `Active`.
    *   **Роль пользователя:** Проверка, что пользователь не является "Никитой", чьи тапы не учитываются.

## 6. Масштабируемость бекенда

Требование поддержки нескольких инстансов бекенда (например, 3 Node.js процесса за реверс-прокси) диктует необходимость stateless-архитектуры:

*   **Stateless-серверы:** Каждый инстанс бекенда не должен хранить состояние, специфичное для конкретного пользователя или запроса, между запросами. Все необходимое состояние (например, сессия пользователя) должно быть извлечено из внешнего источника (например, из JWT) или из базы данных.
*   **Общая база данных:** Все инстансы бекенда будут подключаться к одной и той же базе данных PostgreSQL. Это централизует хранение состояния и обеспечивает его доступность для любого инстанса.
*   **Механизмы блокировки базы данных:** Использование транзакций и `SELECT ... FOR UPDATE` (как описано выше) является ключевым для поддержания консистентности данных при одновременных запросах от разных инстансов бекенда.
*   **Идемпотентные операции:** Желательно, чтобы API-операции были идемпотентными там, где это возможно, чтобы повторные запросы (например, из-за сетевых ошибок) не приводили к нежелательным побочным эффектам.

## 7. Фоновые процессы для управления раундами

Для автоматического изменения статуса раундов (`Cooldown` -> `Active` -> `Finished`) на бекенде будет реализован простой механизм:

*   **Таймер/Планировщик:** На каждом инстансе бекенда (или на одном выделенном) будет запущен `setInterval`, который периодически (например, раз в секунду или раз в несколько секунд) проверяет базу данных на наличие раундов, статус которых необходимо обновить.
*   **Логика обновления:**
    *   Найти раунды со статусом `Cooldown`, у которых `startTime` уже наступило, и обновить их статус на `Active`.
    *   Найти раунды со статусом `Active`, у которых `endTime` уже наступило, и обновить их статус на `Finished`.
*   **Учет множества инстансов:** Если `setInterval` будет запущен на всех инстансах, нужно предусмотреть механизмы для избежания повторных обновлений одного и того же раунда (например, с помощью транзакций и блокировок, или уникальных индексов на статус, если это применимо, хотя в данном случае простая транзакция на обновление будет достаточной). В случае простой реализации, несколько инстансов могут пытаться обновить один и тот же раунд, но благодаря транзакциям и `WHERE` условиям в запросе `UPDATE`, только одна операция будет успешной.
